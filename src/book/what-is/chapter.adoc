[[chapter_what_is]]
== What is User Journey Testing?

Testing has been important to me as a professional software engineer for as long as I can remember. 

Now, I'm not suggesting that I've been writing tests since the very beginning, or that I always write tests, or even that the tests I write are particularly good. But my first professional development gigs as a software consultant were in Java in the late 1990s, and a new project called _JUnit_ -- a unit testing framework written by Erich Gamma and Kent Beck -- was really taking off. 

What intrigued me about JUnit at the time was that it was not just a simple testing library -- it was a key part of a philosophy called _Test-Driven Development_ (*TDD*), which in turn was a key part of a larger system of agile practices called _Extreme Programming_ (*XP*). Not surprisingly, Kent Beck (along with co-author Martin Fowler) wrote a book about all of these practices called _Planning Extreme Programming_ -- one of the first books I read on the subject.

Despite the "Extreme" qualifier in XP, the practices recommended by XP seemed quite sensible and practical: 

* Customers pick the features to be added
* Programmers add the features so that they are completely ready to be used
* Programmers and customers write and maintain automated tests to demonstrate the presence of these features

This felt like such common sense to me at the time that I couldn't fully grasp why all software developers didn't use this approach. If I drop my car off at the repair shop and say, "When I drive above 55 miles per hour, I hear a loud clanking", I fully expect the mechanic to:

* Drive my car above 55 miles per hour so that they can hear (and verify) the clanking sound
* Fix the clanking
* Demonstrate to me, when I pick up my car after the repair, that the clanking is gone by driving above 55 miles per hour with me in the car

Now, if you've been programming for a while, you might be thinking, "That clanking is a bug, not a feature!" And while you're technically correct, what different behavior would you expect if I dropped my car off and said instead, "I'd like you to upgrade my sound system" or "I'd like you to install a new sun roof"? I'd expect the same sequence of events. Wouldn't you?

=== So then, what is User Journey Testing? 

Suppose my client says to me, "I need a website for a software conference I'm running. I'd like to have a page that lists all of the speakers. When you click on a speaker, I'd like that to lead to a page with their biography and a list of their talks." What they just described to me is a _User Journey_. 

I now understand the feature they're asking for. I can add that feature with relatively little effort. But how can I demonstrate the new feature I just added?

As the developer of the feature, I probably manually go through the sequential steps of "Go to the Speakers Page; Click on a Speaker; Verify that I end up on a page with the Speaker's biography and list of talks" tens, if not hundreds, of times during the development process. After all, I want to be fully convinced that the process works before I demonstrate it to my client. 

But manual testing can be time consuming and prone to error if not done consistently. What if I could automate the User Journey? What if I could write a little bit of code that tests the User Journey in a consistent, repeatable manner? Something like this:

[code, javascript]
.A User Journey test written in Taiko
----
openBrowser()
goto('https://thirstyhead.com/conferenceworks/speakers/')
click('Dr. Rebecca Parsons')
highlight('About')
highlight('Talks')
screenshot({path:'speakerListTest-screenshot.png'})
----

.The resulting screenshot from the User Journey test
image::what-is/speakerListTest-screenshot.png[Screenshot from the User Journey Test]

_Taiko_ is an open source Node.js library for testing modern web applications. It is a purpose-built _Domain Specific Language_ (*DSL*) for writing User Journey tests. Anything that your user can do on your website can be automated using Taiko. So, if your user does this on their Login journey:   

* Go to the Login page
* Click the 'Username' field
* Write in the user name
* Click the 'Password' field
* Write in the password
* Click the Submit button 

...you can automate that with Taiko like this:

[code, javascript]
.Automating the Login User Journey with Taiko
----
openBrowser()
goto('https://thirstyhead.com/conferenceworks/login')
click('Username')
write('suzi@q.com')
click('Password')
write('wordpass')
click('Submit')
----

Of course, TDD is no more tied to JUnit than User Journey testing is tied to Taiko. User Journey testing is a practice -- a discipline -- that can be implemented in a variety of different languages, using a variety of different libraries. If you can practice TDD by using a library other than JUnit (say, _NUnit_ for .NET languages, or _Test::Unit_ for Ruby), then you can certainly write User Journey tests using a library other than Taiko. But I'll continue to use Taiko here whenever I need to explain a concept in code.

If you'd like to follow along and run the Taiko tests yourself, installing Taiko is as simple as `npm install -g taiko`. Once Taiko is installed, you can type `taiko` at the command prompt to enter the interactive REPL and explore on your own. Anything that you type in the Taiko REPL can be exported to modern JavaScript by typing `.code` to see the code on screen, or by typing `.code mytest.js` to save the JavaScript to the current working directory. After that, you can type `taiko mytest.js` to run the code outside of the REPL by hand or, say, in your _Continuous Delivery_ (*CD*) pipeline.  

=== Where do User Journey Tests live on the Testing Spectrum?

One of the most important aspects of unit testing is, well, the unit of code being tested. More specifically, the size of the unit. The goal of unit testing is to focus on the smallest cohesive hunk of code that you can tease apart from the rest of the application in isolation. I often say that unit tests "test the bricks, not the building" because, after all, you can't trust the building if you don't trust the bricks. 

If your unit of code interacts with a database, or a file system, or a remote web service, it's common to _mock_ or _stub_ out those services with a fast, in-memory doppelg√§nger that behaves just like the original service does, but without the latency and brittleness that depending on an external service might introduce.  

Author Mike Cohn, in his book _Succeeding with Agile_, introduced a powerful visual metaphor for this with the _Test Pyramid_.

image::what-is/testPyramid.png

